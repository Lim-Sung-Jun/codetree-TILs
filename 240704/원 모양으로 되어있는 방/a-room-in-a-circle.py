# # 거리의 최소합? 이해 x

# 어떤 방에서 시작?
# 방에 인원이 들어가는데 거리의 합?
# 2번방 시작
# 예시로 풀었으면 -> n으로 일반화해야지

# 문제 이해가 잘 안갔다.
# 예시를 보고 이해했고 특정 방에서 시작해서 각 방에 모든 인원에 대한 거리의 합을 구했다.
# distance는 1씩 증가시키면 됐는데
# 0 -> 1 -> 2 .. -> n -1 이렇게 이미 순서가 있어서
# 이게 0에서 시작, 3에서 시작 등 임의의 위치에서 시작할 때 순서를 어떻게 지켜야할지 생각했다.
# 어떤 점에서 시작하든지 결국 n - 1번 움직여야 하고 그건 인덱스는 원을 따르므로
# for문으로 n-1번 반복 and 원을 따르므로 인덱스를 j % n을 사용했다.
# 그러면 0, 1, 2,..을 만족한다.
# 나머지를 이용하면 원에 대한 인덱스를 표현할 수 있고 어디서 시작해도 사용할 수 있다.
# 모든 방에서 시작하는 완전탐색 문제

# 해설지에서는 각 방에서 시작하고 dist 구하고 사람 수 구해서 곱해서 더해주면된다.
# dist를 어떻게 구했을까?
# (j + n - i) % n
# 2번방 - 1번방, 3번방 - 1번방, ..
# 1번방 - 2번방은 -1가 된다.  그럼 4번 이동해야하니깐 -1에 5를 더한다.
# 즉, 2 -> 3방, 2-> 4방, 2->5방 은 j - i를 하면 된다.
# 근데 2 -> 1방이면 2,3,4,5를 거쳐야하므로 전체 5에서 -1하면 된다.
# 일반화하면 j-i에다가 음수도 처리하기 위해서 j-i+n이 된다. # 근데 이제 순환하므로 n을 나눠준다.
# 거릴잴때 참고

# 순환 회전 (Circular Rotation)
# new_index = (i + k) % n
# 순환 배열에서의 거리 계산
#  dist = (j + n - i) % n

n = int(input())
room = []

for i in range(n):
    room.append(int(input()))

answer = float('inf')
for i in range(n):
    distance = 1
    result = 0
    j = i + 1
    # count = 1 # 이걸 딱 4번만 반목하는 방법? 그냥 for문 쓰면 되는구나 n번 반복이네

    # while count < 5:
    for k in range(n-1):
        result += room[j % n] * distance # 이것도 일반화
        distance += 1
        j += 1
    answer = min(result, answer)

print(answer)